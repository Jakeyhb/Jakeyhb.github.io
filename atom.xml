<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jakeby</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-08-21T17:37:14.758Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jakeby</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试</title>
    <link href="http://yoursite.com/2023/08/17/%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2023/08/17/%E9%9D%A2%E8%AF%95/</id>
    <published>2023-08-16T17:12:41.000Z</published>
    <updated>2023-08-21T17:37:14.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-高频面试题"><a href="#Vue-js-高频面试题" class="headerlink" title="Vue.js 高频面试题"></a>Vue.js 高频面试题</h2><ol><li><p>什么是 Vue.js？<br>答案： Vue.js 是一个渐进式 JavaScript 框架，用于构建用户界面。它专注于实现数据驱动的组件化架构，通过简单的 API 使构建交互式的 Web 应用变得更加容易。</p></li><li><p>Vue.js 中的双向数据绑定是如何实现的？<br>答案： Vue.js 通过使用其核心库实现了双向数据绑定。它利用了 JavaScript 的 Object.defineProperty 方法来追踪属性的变化，并在数据变化时更新视图，同时在视图中的输入元素上监听用户的输入，将数据的变化反映回数据模型。</p></li><li><p>Vue.js 中的指令是什么？<br>答案： 指令是 Vue.js 提供的一种特殊属性，通过在 HTML 标签上添加前缀 v-来表示。它们用于实现 DOM 元素的动态行为和交互，例如 v-if、v-for、v-bind、v-on 等。</p></li><li><p>什么是 Vue 组件？如何定义一个组件？<br>答案： 组件是 Vue.js 应用中的可复用、独立的代码模块，具有自己的模板、逻辑和样式。组件通过 Vue.component 方法定义，或者使用单文件组件（以.vue 文件形式编写），包括模板、脚本和样式。</p></li><li><p>什么是 Vue 路由？<br>答案： Vue 路由是用于构建单页应用（SPA）的插件，允许在不同的 URL 之间切换，而不需要重新加载页面。它基于 Vue.js 提供了管理路由、视图映射以及路由切换的功能。</p></li><li><p>Vue 中的生命周期钩子有哪些？<br>答案： Vue 实例有多个生命周期钩子，包括 beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy 和 destroyed。这些钩子允许你在组件不同阶段执行自定义代码。</p></li><li><p>Vue 的计算属性和侦听器有什么区别？<br>答案： 计算属性是根据依赖的数据动态计算得出的属性，具有缓存机制。而侦听器是监听特定数据的变化，在数据变化时执行相应的回调函数。计算属性适用于对数据进行处理和衍生，而侦听器适用于对数据变化做出响应。</p></li><li><p>Vuex 是什么？它解决了什么问题？<br>答案： Vuex 是 Vue.js 的官方状态管理库，用于在大型应用中管理应用的状态（数据）。它解决了多个组件之间共享状态、数据流管理、状态变更的追踪与调试等问题。</p></li><li><p>Vue 中的动态组件是什么？<br>答案： 动态组件是指可以根据数据动态切换的组件。Vue 提供了<component>元素以及相应的 is 特性，允许根据数据来渲染不同的组件。</p></li><li><p>Vue 3 相对于 Vue 2 有哪些重要的改变？<br>答案： Vue 3 相对于 Vue 2 进行了一些重要的改变，包括：</p></li></ol><p>更快的渲染性能和更小的包体积。<br>Composition API，提供更灵活的组合式逻辑复用。<br>更好的 TypeScript 支持。<br>更强大的响应式系统。<br>Teleport 组件，用于更精确地控制组件渲染的位置。<br>更好的 Tree Shaking 支持，减少无用代码的体积</p><h2 id="JavaScript-高频面试题"><a href="#JavaScript-高频面试题" class="headerlink" title="JavaScript 高频面试题"></a>JavaScript 高频面试题</h2><ol><li><p>解释 JavaScript 中的事件委托（Event Delegation）是什么？为什么它有用？<br>答案： 事件委托是一种通过将事件处理程序附加到其父元素而利用事件冒泡的机制来管理大量子元素的技术。这意味着当子元素触发事件时，事件会冒泡到父元素，从而执行单一的事件处理程序，这样可以减少事件处理程序的数量，提高性能，并且对于动态添加的子元素也能正常工作。</p></li><li><p>什么是闭包（Closure）？请举一个使用闭包的例子。<br>答案： 闭包是指函数能够访问其定义时的词法作用域，即使函数在其定义的作用域之外执行。这允许函数“记住”其创建时的环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> outerVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(outerVar); <span class="comment">// 这里使用了闭包，可以访问 outerVar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closureExample = outerFunction();</span><br><span class="line">closureExample(); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>什么是原型链（Prototype Chain）？它是如何工作的？<br>答案： 原型链是 JavaScript 中对象之间的连接，每个对象都有一个指向其原型的链接。当访问对象的属性或方法时，如果对象本身没有找到，JavaScript 会在原型链上继续查找。这允许对象共享属性和方法，从而实现了继承。</p></li><li><p>解释同步（Synchronous）和异步（Asynchronous）的区别。<br>答案： 同步操作是指代码按顺序执行，每个操作必须在前一个操作完成之后才能开始。异步操作是指代码不按顺序执行，可以在其他操作运行时开始执行，通常与回调函数、Promise、async/await 等一起使用。</p></li><li><p>什么是回调地狱（Callback Hell）？如何避免它？<br>答案： 回调地狱是指在异步操作中，多次嵌套使用回调函数，导致代码可读性差、难以维护的情况。为了避免回调地狱，可以使用 Promise、async/await 等技术，将异步操作以更可读、线性的方式组织起来。</p></li><li><p>如何检查一个变量的数据类型？<br>答案： 使用 typeof 操作符可以检查一个变量的数据类型。然而，它在某些情况下可能返回不准确的结果，例如 typeof null 会返回”object”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"hello"</span>; <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// "object"（注意这是个特例）</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>解释什么是同源策略（Same-Origin Policy）？<br>答案： 同源策略是一种安全机制，它限制了来自不同源（域名、协议或端口）的网页对当前网页的访问。这是为了防止恶意代码通过访问其他域上的资源来窃取数据。</p></li><li><p>什么是箭头函数（Arrow Functions）？它们与普通函数有什么区别？<br>答案： 箭头函数是一种简化函数定义语法的方式，它没有自己的 this、arguments、super 或 new.target，它们会捕获在外围作用域中的这些值。箭头函数不能用作构造函数。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure><ol start="9"><li><p>解释事件冒泡（Event Bubbling）和事件捕获（Event Capturing）。<br>答案： 事件冒泡是指当一个元素上的事件被触发时，它会从最深的嵌套元素开始冒泡至最外层的元素。事件捕获是指相反的过程，事件从最外层元素开始捕获直到最深的嵌套元素。在大多数情况下，浏览器默认使用事件冒泡。</p></li><li><p>解释什么是 Hoisting（变量提升）？<br>答案： Hoisting 是指在 JavaScript 中，变量和函数声明会被提升到作用域的顶部，但实际的赋值操作不会被提升。这意味着在变量被声明之前就使用它，会得到 undefined，而不会报错。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue-js-高频面试题&quot;&gt;&lt;a href=&quot;#Vue-js-高频面试题&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 高频面试题&quot;&gt;&lt;/a&gt;Vue.js 高频面试题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是 Vue.js？&lt;br&gt;答案： Vu</summary>
      
    
    
    
    <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>My 2021</title>
    <link href="http://yoursite.com/2022/01/11/My-2021/"/>
    <id>http://yoursite.com/2022/01/11/My-2021/</id>
    <published>2022-01-11T15:10:06.000Z</published>
    <updated>2022-01-11T15:16:42.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不觉已经快过完2021年了, 感觉就是一瞬间的事情, 现在用一些app, 让我滚动选择出生年月日的时候, 我居然要往下滚动这么长的时间, 慢慢地意识到自己的年龄在逐步的增大, 内心的焦虑优雅而生, 这也让我回忆起很多往事….</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年是技术成长较为平缓的一年，也是自我转变的一年。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不觉已经快过完2021年了, 感觉就是一瞬间的事情, 现在用一些app, 让我滚动选择出生年月日的时候, 我居然要往下滚动这么长的时间, 慢</summary>
      
    
    
    
    
    <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>blogsCorrelation</title>
    <link href="http://yoursite.com/2020/11/09/blogsCorrelation/"/>
    <id>http://yoursite.com/2020/11/09/blogsCorrelation/</id>
    <published>2020-11-08T18:30:24.000Z</published>
    <updated>2020-11-08T18:31:35.464Z</updated>
    
    <content type="html"><![CDATA[<h5 id="以下命令需要在本地Blog路径下执行"><a href="#以下命令需要在本地Blog路径下执行" class="headerlink" title="以下命令需要在本地Blog路径下执行"></a>以下命令需要在本地Blog路径下执行</h5><h3 id="Step1-创建文章"><a href="#Step1-创建文章" class="headerlink" title="Step1 创建文章"></a>Step1 创建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br><span class="line">$ hexo n <span class="string">"My New Post"</span>    //安装hexo-asset-image后可使用</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="Step2-编辑文章"><a href="#Step2-编辑文章" class="headerlink" title="Step2 编辑文章"></a>Step2 编辑文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文章头部加</span><br><span class="line">---</span><br><span class="line">title: //此处填写文章名</span><br><span class="line">date: //此处填写发布日期</span><br><span class="line">tags: </span><br><span class="line">  - //此处填写标签名(可多个)</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><p>由于在首页中显示文章内容使用的是 <code>post.content</code> 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个 <code>&lt;!-- more --&gt;</code> 标记。添加了这个标记之后，<code>post.excerpt</code> 将会获取到标记之前的内容</p><p>之后的内容大家可以随意Diy啦</p><p>编辑md文件建议使用Typora软件 特别推荐！！！</p><h4 id="关于文章添加图片："><a href="#关于文章添加图片：" class="headerlink" title="关于文章添加图片："></a>关于文章添加图片：</h4><p> 1 把本地Blog文件下的配置文件（非主题下）<code>_config.yml</code>里的<code>post_asset_folder:</code>选项设置为<code>true</code></p><p> 2 在本地Blog路径下执行<code>npm install hexo-asset-image --save</code> （用于下载安装一个可以上传本地图片的插件）</p><p> 3 运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文</p><p> 会发现在/source/_posts<code>文件夹中除了</code>xxxx.md`文件还生成了一个同名文件夹</p><p> 4最后在<code>xxxx.md</code>引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Step3-清除缓存-（可省略-建议使用）"><a href="#Step3-清除缓存-（可省略-建议使用）" class="headerlink" title="Step3 清除缓存 （可省略 建议使用）"></a>Step3 清除缓存 （可省略 建议使用）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>清除缓存文件 db.json 和已生成的静态文件 public</p><p>当网站显示异常时可以执行这条命令试试</p><h3 id="Step4-生成静态文件"><a href="#Step4-生成静态文件" class="headerlink" title="Step4 生成静态文件"></a>Step4 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g      //简写</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>这步骤就相当于程序的编译，如果有错误的话，在终端会有相应的提示信息</p><p>如果没有错误的话 可以继续往下执行</p><h3 id="Step5-启动本地服务器-（可省略）"><a href="#Step5-启动本地服务器-（可省略）" class="headerlink" title="Step5 启动本地服务器 （可省略）"></a>Step5 启动本地服务器 （可省略）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s      //简写</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>用于预览主题，默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h3 id="Step6-部署到远程站点"><a href="#Step6-部署到远程站点" class="headerlink" title="Step6 部署到远程站点"></a>Step6 部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d       //简写</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;以下命令需要在本地Blog路径下执行&quot;&gt;&lt;a href=&quot;#以下命令需要在本地Blog路径下执行&quot; class=&quot;headerlink&quot; title=&quot;以下命令需要在本地Blog路径下执行&quot;&gt;&lt;/a&gt;以下命令需要在本地Blog路径下执行&lt;/h5&gt;&lt;h3 id=&quot;S</summary>
      
    
    
    
    <category term="blogs" scheme="http://yoursite.com/categories/blogs/"/>
    
    
    <category term="博客操作" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>我的生活</title>
    <link href="http://yoursite.com/2020/11/09/%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2020/11/09/%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/</id>
    <published>2020-11-08T18:27:10.000Z</published>
    <updated>2020-11-08T18:31:39.890Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读路遥的《平凡的世界》、克里希那穆提的《重新认识你自己》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在读路遥的《平凡的世界》、克里希那穆提的《重新认识你自己》&lt;/p&gt;
</summary>
      
    
    
    
    <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="点滴" scheme="http://yoursite.com/tags/%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>前端面试</title>
    <link href="http://yoursite.com/2020/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2020-06-28T00:30:34.000Z</published>
    <updated>2020-07-07T00:55:49.228Z</updated>
    
    <content type="html"><![CDATA[<p>前端面试题总结：jakeby</p><blockquote><p><strong>2020，6.28</strong>  </p></blockquote><h1 id="react-相关"><a href="#react-相关" class="headerlink" title="react 相关"></a>react 相关</h1><ol><li><p><strong>react父子组件的传值？子组件设置ref？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">父组件传子组件：</span><br><span class="line">父传值：&lt;子的标签 value&#x3D;&#123;&#39;aaa&#39;&#125; index&#x3D;&#123;&#39;bbb&#39;&#125;&gt;&lt;&#x2F;子的标签&gt;</span><br><span class="line">    子接值：&lt;li key&#x3D;&#123;this.props.index&#125;&gt;&#123;this.props.value&#125;&lt;&#x2F;li&gt;</span><br><span class="line">子组件传值到父组件：</span><br><span class="line">在父组件调用子组件的时候，给子组件设置一个属性，属性的值对应的是一个函数</span><br><span class="line">    子组件中需要传值的时候就props调用该函数，并且将传的值作为参数传入，</span><br><span class="line">    在父组件中，调用函数被执行，通过参数列表得到子组件传入的值</span><br><span class="line">设置ref：</span><br><span class="line"></span><br><span class="line">    react.CreateRef()</span><br><span class="line">    通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中</span><br><span class="line">    那么该变量的current则指向绑定的标签dom</span><br></pre></td></tr></table></figure><p><img src="..%5Cimages%5Cwork%5C1.png" alt="ref"></p></li><li><p><strong>在 React 中，refs 的作用是什么</strong></p><blockquote><p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p></blockquote></li><li><p>在父组件中获得子组件的属性？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>非受控组件怎么设置默认值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">非受控组件：默认值：defaultValue</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* 受控组件 */</span>&#125;</span><br><span class="line"> 受控组件就是我们的值可以控制，比如数据的双向绑定；</span><br><span class="line"> &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.inputVal&#125; onChange=&#123;<span class="keyword">this</span>.changeAction.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">  &#123;<span class="comment">/* 非受控组件 */</span>&#125;</span><br><span class="line">  非受控组件就是值没办法改变，设置的值是多少就是多少，</span><br><span class="line">  不会受到输入的改变而改变</span><br><span class="line"> &#123; &lt;input type=<span class="string">"text"</span> ref=<span class="string">"in"</span> defaultValue=&#123;<span class="keyword">this</span>.state.inputVal&#125;/&gt; &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>2020，6.29</p></blockquote><ol><li><p><strong>react16.0之后的新增的特性:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">友情链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_18283943&#x2F;article&#x2F;details&#x2F;106186916</span><br><span class="line">hooks</span><br><span class="line">Fragment(v16.0) &amp; StrictMode(v16.3)</span><br><span class="line">与 Fragment 相同，并不会被渲染成真实 DOM。</span><br><span class="line">context()。。。。</span><br></pre></td></tr></table></figure></li><li><p><strong>react中父子组件之间的传值；</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父子组件传值：父组件通过初始的state   子组件通过<span class="keyword">this</span>.props</span><br><span class="line">子组件向父组件传值需要绑定一个事件，</span><br><span class="line">然后事件是父组件传递过来的<span class="keyword">this</span>.props.event来进行值的更替。</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>vue组件中data的声明为什么是一个函数；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们知道作用域分为全局作用域、局部作用域（函数作用域）、块级作用域（es6）。</span><br><span class="line">组件中的data设置为一个函数，相当于每个组件实例都有自己的作用域，那么局部作用域中的数据改变是不会影响其他作用域的，也就是说每个组件相互独立，互不影响。这样就保证了组件的复用性和灵活性。</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>react中函数可以有自己状态吗？useState  如何使用；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数组件没有实例，也没有状态。函数组件使用状态需要使用 useState 钩子</span><br><span class="line">原理：</span><br><span class="line">写一个 useState 方法，会返回当前状态的属性和设置状态的方法，每当状态改变之后，方法中会调用刷新视图的 render 方法。</span><br><span class="line">再次尝试之前的代码，依然可以正常使用，但是当多个 useState 存在的时候就有问题了，只能变一个状态了。</span><br><span class="line">现在我们需要优化我们的 Hooks ，解决多个 useState 同时使用的问题，当多个状态存在的时候，我们需要使用数组保存状态</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h2 id="react中的生命周期："><a href="#react中的生命周期：" class="headerlink" title="react中的生命周期："></a>react中的生命周期：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">react生命周期分为初始化阶段、运行阶段、销毁阶段。</span><br><span class="line">(1) 初始化阶段：</span><br><span class="line"></span><br><span class="line">componentWillMount：实例挂载之前</span><br><span class="line">Render：渲染组件</span><br><span class="line">componentDidMount：实例挂载完成。一般在这个函数中与后台进行初始化数据交互。</span><br><span class="line"></span><br><span class="line">(2)运行阶段：</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps：父组件改变时调用。</span><br><span class="line">sholudComponentUpdate：主要是用来手动阻止组件渲染，一般在这个函数中做组件的性能优化。</span><br><span class="line">componentWillUpdate：组件数据更新前调用</span><br><span class="line">componentDidUpdate：组件数据更新完成时调用</span><br><span class="line"></span><br><span class="line">(3)销毁阶段：</span><br><span class="line"></span><br><span class="line">componentUnmount：销毁阶段。一般用来销毁不用的变量或者是解除无用定时器以及解绑无用事件。防止内存泄漏问题。</span><br><span class="line">运行阶段生命周期调用顺序</span><br><span class="line">componentWillReceiveProps–&gt;shouldComponentUpdate --&gt; componentWillupdate --&gt; componentDidUpdate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">react生命周期中，最适合与服务端进行数据交互的是哪个函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">componentDidMount：在这个阶段，实例和dom已经挂载完成，可以进行相关的dom操作。</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><h2 id="作用域链和作用域"><a href="#作用域链和作用域" class="headerlink" title="作用域链和作用域"></a>作用域链和作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的</span><br><span class="line">简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</span><br><span class="line"></span><br><span class="line">扩展：JavaScript原型，原型链 ? 有什么特点？</span><br><span class="line">每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时</span><br><span class="line"></span><br><span class="line">如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</span><br><span class="line"></span><br><span class="line">关系：instance.constructor.prototype &#x3D; instance.__proto__</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line">JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</span><br><span class="line">当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</span><br><span class="line"></span><br><span class="line">就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><h2 id="react中状态提升："><a href="#react中状态提升：" class="headerlink" title="react中状态提升："></a>react中状态提升：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要解决是数据共享的问题：</span><br><span class="line">就是如果两个子组件需要利用到对方的状态的话，那么这个时候我们就需要使用到状态提升，具体的做法就是把两个子组件的状态写到它们的父组件当中，然后父组件把状态传递到子组件的props中去，这样子组件也相当于有状态。父组件相当于是数据源，这样的话，子组件是没有控制权的，</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><h2 id="react中为什么要使用immutable"><a href="#react中为什么要使用immutable" class="headerlink" title="react中为什么要使用immutable"></a>react中为什么要使用immutable</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">因为在react中，react的生命周期中的setState()之后的shouldComponentUpdate()阶段默认返回true，所以会造成本组件和子组件的多余的render，重新生成virtual dom，并进行virtual dom diff，所以解决办法是我们在本组件或者子组件中的shouldComponentUpdate()函数中比较，当不需要render时，不render。</span><br><span class="line"></span><br><span class="line">当state中的值是对象时，我们必须使用深拷贝和深比较！</span><br><span class="line"></span><br><span class="line">如果不进行深拷贝后再setState，会造成this.state和nextState指向同一个引用，所以shouldComponentUpdate()返回值一定是false，造成state值改了，而组件未渲染（这里不管shouldComponentUpdate中使用的是深比较还是浅比较）。所以必须深拷贝。</span><br><span class="line"></span><br><span class="line">如果不在shouldComponentUpdate中进行深比较，会造成即使state中的对象值没有改变，因为是不同的对象，而在shouldComponentUpdate返回true，造成不必要的渲染。</span><br><span class="line"></span><br><span class="line">所以只能是深拷贝和深比较。</span><br><span class="line"></span><br><span class="line">而深拷贝和深比较都浪费浏览器的性能，所以immutable登场了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">与React搭配使用，关键点是shouldComponentUpdate</span><br><span class="line">熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，尽管React的虚拟算法复杂度已经有了很多优化，但是在大规模组件更新时，依然会是个不必要的损耗。会带来很多无必要的渲染并成为性能瓶颈。</span><br><span class="line">我们常用的Purecomponent的秘密其实是在shouldComponentUpdate中做了前后state和props的浅比较，如果不小心组件props的引用问题，这里会导致出现很多Bug。</span><br><span class="line">虽然第一层数据没变，但引用变了，就会造成虚拟 DOM 计算的浪费。</span><br><span class="line">第一层数据改变，但引用没变，会造成不渲染，所以需要很小心的操作数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object.assign可以实现不可变数据,唯一的就是性能问题</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>2020,7月1</p></blockquote><ol><li><h2 id="hooks是什么"><a href="#hooks是什么" class="headerlink" title="hooks是什么"></a>hooks是什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？</span><br><span class="line"></span><br><span class="line">React 早期版本，类组件可以通过继承PureComponent来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 React.memo函数。</span><br><span class="line"></span><br><span class="line">React 16.8 新出来的Hook可以让React 函数组件具有状态，并提供类似 componentDidMount和componentDidUpdate等生命周期方法。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h2 id="context的用法"><a href="#context的用法" class="headerlink" title="context的用法"></a>context的用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">新版本的用法有点像react-redux，外层使用Provider包裹，然后在value处注入上下文环境，然后后代组件用Customer包裹，用来接收上下文</span><br><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">const Test1Context &#x3D; React.createContext(&#123;</span><br><span class="line">    user:&#123;name:&quot;asdf&quot;&#125;,</span><br><span class="line">    text:&quot;asdfdsaf&quot;</span><br><span class="line">&#125;);</span><br><span class="line">class A extends React.Component &#123;</span><br><span class="line">    state &#x3D;&#123;</span><br><span class="line">      user: this.props.user，</span><br><span class="line">      text: &quot;item text&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;Test1Context.Provider value&#x3D;&#123;this.state&#125;&gt;</span><br><span class="line">            &lt;div&gt;&#123;this.props.children&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;Test1Context.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.createContext()传入的东西用于设置默认值,也可以不传。</span><br><span class="line">这个包裹的Provider，要改成你定义的上下文名字+.Provider，这里我定义的上下文环境名字叫 Test1Context，所以我render里面包裹的是Test1Context.Provider。</span><br><span class="line">value里可以放任意的东西，比如放一个对象，放个数组，放个字符、数字，放个function，都ok。</span><br><span class="line">然后再是后代组件D</span><br><span class="line"></span><br><span class="line">class D extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &lt;Test1Context.Consumer&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">              &#123;this.context.user.name&#125;</span><br><span class="line">              &#123;(value)&#x3D;&gt;&lt;div&gt;value.user.name&lt;&#x2F;div&gt;&#125;</span><br><span class="line">              &#123;(&#123;user&#125;)&#x3D;&gt;&lt;div&gt;user.name&lt;&#x2F;div&gt;&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Test1Context.Consumer&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">D.contextType &#x3D; Test1Context ;</span><br><span class="line"></span><br><span class="line">(或者在D里面 static contextType &#x3D; Test1Context )</span><br><span class="line">可以在生命周期里面使用，官方文档是这样写的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> class MyClass extends React.Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* perform a side-effect at mount using the value of MyContext *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let value &#x3D; this.context;</span><br><span class="line">    &#x2F;* render something based on the value of MyContext *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType &#x3D; MyContext;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>2020,7月6号</p></blockquote><ol><li><p><strong>组件的拆分规则：</strong></p><p>解耦：降低组件单一模块、组件复杂度</p><p>复用：保证组件的一致性，提升开发效率</p><p>组件颗粒度需要避免过大或者过小</p></li></ol><ol start="2"><li><p><strong>react  ref  获取dom  和组件的相关值</strong></p><p>Ref 转发是一项将 <a href="https://react.docschina.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">ref</a> 自动地通过组件传递到其一子组件的技巧；</p><p>ref 是一个入口 允许您直接访问DOM元素或组件实例。为了使用它们，可以向组件添加一个ref属性，该属性的值是一个回调函数，它将接收底层的DOM元素或组件的已挂接实例作为其第一个参数。</p></li></ol><ol start="3"><li><p><strong>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate</span><br><span class="line">询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。</span><br><span class="line">这个方法用来判断是否需要调用 render 方法重新描绘 dom。</span><br><span class="line">因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>指出(组件)生命周期方法的不同</strong></p><blockquote><p>componentWillMount – 多用于根组件中的应用程序配置<br>componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成<br>componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换<br>shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染<br>componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)<br>componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变<br>componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</p></blockquote></li></ol><ol start="5"><li><p><strong>指出(组件)生命周期方法的不同</strong></p><blockquote><p>componentWillMount – 多用于根组件中的应用程序配置<br>componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成<br>componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换<br>shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染<br>componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props)<br>componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变<br>componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</p></blockquote></li><li><p><strong>react中key的作用</strong></p><blockquote><p>key是React中用于追踪哪些列表中元素被修改、删除或者被添加的辅助标识。在diff算法中，key用来判断该元素节点是被移动过来的还是新创建的元素，减少不必要的元素重复渲染。</p></blockquote></li><li><p><strong>vue和react的区别</strong></p><p>1、react严格上针对的是mvc模式的view层，vue则是mvvm模式。<br>2、操作dom的方式不同，vue使用的是指令操作dom，react是通过js进行操作。<br>3、数据绑定不同，vue实现的是双向绑定，react的数据流动是单向的。<br>4、react中state是不能直接改变的，需要使用setState改变。vue中的state不是必须的，数据主要是由data属性在vue对象中管理的。</p></li></ol><ol start="8"><li><p><strong>react中组件传值</strong></p><blockquote><p>父传子（组件嵌套浅）：父组件定义一个属性，子组件通过this.props接收。<br>子传父：父组件定义一个属性，并将一个回调函数赋值给定义的属性，然后子组件进行调用传过来的函数，并将参数传进去，在父组件的回调函数中即可获得子组件传过来的值。</p></blockquote></li><li><p><strong>react性能优化的方案</strong></p><blockquote><p>（1）重写shouldComponentUpdate来避免不必要的dom操作。<br>（2）使用 production 版本的react.js。<br>（3）使用key来帮助React识别列表中所有子组件的最小变化。</p></blockquote></li><li><p><strong>应该在 React 组件的何处发起 Ajax 请求</strong></p><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 <code>componentDidMount</code> 中发起网络请求将保证这有一个组件可以更新了。</p></li><li><p><strong>何为高阶组件(higher order component)</strong></p><blockquote><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 <code>connect</code> 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p></blockquote></li><li><p><strong>react diff 原理（常考，）</strong></p><p>React Diff：</p><p>之前说过，React采用虚拟DOM技术实现对真实DOM的映射，即React Diff算法的差异查找实质是对两个JavaScript对象的差异查找；<br>基于三个策略：<br>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（tree diff）<br>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结（component diff）<br>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。（element diff）</p><p>首先需要明确，只有在React更新阶段才会有Diff算法的运用；</p></li></ol><ol start="13"><li><p><strong>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</strong></p><blockquote><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state</p></blockquote></li><li><p><strong>(在构造函数中)调用 super(props) 的目的是什么</strong></p><blockquote><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p></blockquote></li></ol><ol start="15"><li><p><strong>.类组件(Class component)和函数式组件(Functional component)之间有何不同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</span><br><span class="line">当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>redux中间件</p><p><img src="http://jakeby.top/images/work/2.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不使用middleware时，在dispatch(action)时会执行rootReducer，并根据action的type更新返回相应的state。</span><br><span class="line">而在使用middleware时，简言之，middleware会将我们当前的action做相应的处理，随后再交付rootReducer执行。</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//segmentfault.com/a/1190000018347235</span></span><br></pre></td></tr></table></figure></li><li><p>redux有什么缺点 </p><blockquote><p>一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。</p><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。</p></blockquote></li><li><p>react性能优化的方案</p></li></ol><h1 id="js相关："><a href="#js相关：" class="headerlink" title="js相关："></a>js相关：</h1><ol><li><h2 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a><strong>闭包：</strong></h2><p>简单来说，闭包就是一个定义在函数内部的函数。因为js中存在作用域的问题，所以在函数内部定义的变量在函数外部是没有办法直接获取到。而闭包就是沟通函数内部和外部的桥梁，这样在函数外部接可以得到函数内部的值。并且闭包可以实现函数属性和方法的私有化。会构成内存泄露等原因。影响性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br><span class="line">闭包存在的意义就是让我们可以间接访问函数内部的变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">settime是一个异步函数，所以会输出一堆<span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决办法有三种</span><br><span class="line"></span><br><span class="line">第一种是使用闭包的方式</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">在上述代码中，我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的</span><br><span class="line"></span><br><span class="line">第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">第三种就是使用 <span class="keyword">let</span> 定义 i 了来解决问题了，这个也是最为推荐的方式</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a><strong>深浅拷贝</strong></h2><p><strong>浅拷贝</strong></p><blockquote><p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝  … 就是去掉我们对象的外壳</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">'FE'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p></blockquote><p><strong>深拷贝</strong></p><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">'FE'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure></li><li><h2 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h2><p><strong>cookie，localStorage，sessionStorage，indexDB</strong></p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td><td>除非被清理，否则一直存在</td></tr><tr><td>数据存储大小</td><td><code>4K</code></td><td><code>5M</code></td><td><code>5M</code></td><td>无限</td></tr><tr><td>与服务端通信</td><td>每次都会携带在 <code>header</code> 中，对于请求性能影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><blockquote><p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code>存储</p></blockquote><p><strong>对于 cookie 来说，我们还需要注意安全性。</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td><code>http-only</code></td><td>不能通过 <code>JS</code> 访问 <code>Cookie</code>，减少 <code>XSS</code> 攻击</td></tr><tr><td><code>secure</code></td><td>只能在协议为 <code>HTTPS</code> 的请求中携带</td></tr><tr><td><code>same-site</code></td><td>规定浏览器不能在跨域请求中携带 <code>Cookie</code>，减少 <code>CSRF</code> 攻击</td></tr></tbody></table><p><strong>Service Worker</strong></p><ul><li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全</li><li><code>Service Worker</code> 实现缓存功能一般分为三个步骤：首先需要先注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c" alt="img"></p><blockquote><p>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26" alt="img"></p><blockquote><p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p></blockquote></li></ol><ol><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Input Value: "</span>, <span class="keyword">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">'text'</span></span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>判断是数组</strong></p><p>arr instanceof Array</p><p>let arr = [];<br>console.log(arr instanceof Array); </p><p>arr.constructor === Array</p><p>Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数</p><p>Array 原型链上的 isPrototypeOf</p></li></ol><ol start="3"><li><p><strong>let的和var的区别：</strong></p><p>let声明的变量不会提升,并且会产生暂存死区。在let声明变量之前访问变量会抛出错误。</p></li><li><p><strong>forEach和map的区别</strong></p><p>forEach()和map()两个方法都是ECMA5中Array引进的新方法</p><p>forEach：返回值是undefined，不可以链式调用。</p><p>map：返回一个新数组，原数组不会改变。</p><p>相同点：</p><p>1.都是循环遍历数组中的每一项</p><p>2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）</p><p>3.匿名函数中的this都是指向window</p><p>4.只能遍历数组</p><p><strong>map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。</strong></p></li><li><p>发布订阅模式：</p><p>发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知</p><p>首先要想好谁是发布者(比如上面的卖家)。</p><p>然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。</p><p>最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。</p></li><li><p><strong>内存泄露：</strong></p><ul><li>console.log()</li><li>闭包</li><li><strong>dom泄露</strong>：浏览器中DOM和js采用的是不一样的引擎，DOM采用的是渲染引擎，而js采用的是v8引擎，所以在用js操作DOM时会比较耗费性能，因为他们需要桥来链接他们。为了减少DOM的操作，我们一般将常用的DOM。我们会采用变量引用的方式会将其缓存在当前环境。如果在进行一些删除、更新操作之后，可能会忘记释放已经缓存的DOM，</li></ul></li><li><p><strong>Promise的原理：</strong></p><p>首先promise是什么：Promise 是异步编程的一种解决方案，从语法上说，Promise 是一个对象，从它可以获取异步操作的消息，提供统一的api，各种异步操作都可以用同样的方法进行处理；</p><p>Promise标准：</p><p>​    promise当前的状态只能是pending，<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）三种之一</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端面试题总结：jakeby&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2020，6.28&lt;/strong&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;react-相关&quot;&gt;&lt;a href=&quot;#react-相关&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="http://yoursite.com/2020/06/18/React%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/06/18/React%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-18T11:55:32.000Z</published>
    <updated>2020-06-19T14:02:25.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-是什么？"><a href="#React-是什么？" class="headerlink" title="React 是什么？"></a><strong>React 是什么？</strong></h2><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>刚开始我是使用的脚手架搭建我们react的项目（create-react-app）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>全局安装脚手架工具</span><br><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app -V   --检查是否安装成功</span><br><span class="line"><span class="number">2.</span>使用命令建立我们的第一个react的项目，在提前准备好的文件夹下面使用以下命令：</span><br><span class="line">create-react-app 项目名称</span><br><span class="line">    create-react-app my-react  --回车等着跑完</span><br><span class="line"><span class="number">3.</span>建立完之后我们到项目目录下面之后，</span><br><span class="line">npm start  --运行我们的项目，这样我们就可以看见项目初始的界面</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><strong>类组件和函数组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类组件：</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数组件（无状态组件）使用不了this</span></span><br><span class="line"><span class="comment">//跟this相关的都使用不了  state setState   也没有生命周期</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="comment">//外部也设置不了ref</span></span><br><span class="line"><span class="comment">//可以通过函数的参数列表得到props</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//相当于class组件的render()  就不要用ref</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;&#123;props&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们在业务逻辑上我们也可以将函数组件称为UI组件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;React-是什么？&quot;&gt;&lt;a href=&quot;#React-是什么？&quot; class=&quot;headerlink&quot; title=&quot;React 是什么？&quot;&gt;&lt;/a&gt;&lt;strong&gt;React 是什么？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;React 是一个声明式，高效且灵活的用于</summary>
      
    
    
    
    <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>控制情绪，缓解焦虑</title>
    <link href="http://yoursite.com/2020/05/25/%E6%8E%A7%E5%88%B6%E6%83%85%E7%BB%AA%EF%BC%8C%E7%BC%93%E8%A7%A3%E7%84%A6%E8%99%91/"/>
    <id>http://yoursite.com/2020/05/25/%E6%8E%A7%E5%88%B6%E6%83%85%E7%BB%AA%EF%BC%8C%E7%BC%93%E8%A7%A3%E7%84%A6%E8%99%91/</id>
    <published>2020-05-24T18:52:35.000Z</published>
    <updated>2020-05-24T19:00:59.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章摘自：得到APP 张遇升《怎样成为精力管理的高手》</p></blockquote><p>关于情绪的三条定律</p><p>关于情绪有三条重要的定律，这可不是我忽悠你，这是很多心理学家研究的发现。哪三条呢？</p><p>第一条，人的脑子在一个时段只能主要存在一种情绪；</p><p>第二条，相比正面情绪来说，人脑更容易产生负面情绪；</p><p>第三条，人可以通过自主的训练来控制情绪。</p><p>首先，人的脑子在一个时段只能存在一种主要的情绪，真的是这样的吗？</p><p>我打一个比方来说，人的大脑就像一台电视机，有很多不同的频道。它可以放恐怖片、悬疑片、喜剧片甚至爱情片，但是一次只能放一个频道。</p><p>当然你也可能跟我较真，说你在电视上还看见过有人笑着流泪，这不是两种情绪同时存在了吗？这种情况确实存在，但是基本上它是两种情绪切换的时候才会出现。</p><p>你可以想一想，如果笑着流泪的话能够持续吗？最后要不然是继续流泪，要不然是破涕为笑，你说是不是？</p><p>第二条定律，是说相比正面的情绪来说，人脑更容易产生负面的情绪。</p><p>这是为什么呢？这是因为进化的选择。因为人在进化的过程中，我们的第一个任务和最重要的任务，是要活下来，而不是活得开心、活得幸福。</p><p>要活下来，就需要我们的大脑有一种保护机制，就是对危险和潜在的不确定性容易产生恐惧和担心，对“损失”比对“获得”更敏感。</p><p>所以我们在大多数时候都容易莫名其妙地产生一些恐惧、焦虑、忧虑的心理，甚至是莫名其妙地产生负面情绪，这都是正常的。</p><p>但是别忘了最后一点——我们可以通过训练来控制自己的情绪。 </p><p>打个比方说，我们每个人手里都有大脑这个电视机的遥控器，你可以学会切换它的频道。</p><p>美国有个著名的心理学家，叫作芭芭拉·弗雷德里克森说： “我们每天的正面情绪和负面情绪的比例要大于3:1，才能维持积极情绪的正循环。”</p><p>所以，你要保证自己每天的正面情绪在四分之三以上。也正因为如此，你需要主动地去切换情绪的频道。</p><p>但遗憾的是，绝大部分人都没有掌握过这个方法。我下面就想告诉你，怎么样通过一些训练来切换自己情绪的频道。</p><p>如何激发正面情绪</p><p>我教给你的第一个方法叫做 热启动练习（Priming）。它可以帮助你激发自己正面的情绪，让自己感觉到快乐、感恩、兴奋、坚定。接下来我会给你详细介绍，并且带着你来做一遍。</p><p>热启动练习是美国的著名人生教练Tony Robbins自创的一套方法。他每天都会练习，并且他指导过很多名人。像Opera、克林顿，都是这个练习的粉丝。</p><p>它非常像你去运动之前做的热身，你可以想象一下，如果在一个寒冷的早上，你要出去跑步，你前面十分钟是不是会觉得很难受？</p><p>但是如果你在家里做好了热身，你出去的时候就会感觉大不一样。热启动就是帮你的情绪进行热身。当你做好了热身，出门的时候遇到再多的困难或者挑战，你都能够积极地应对。</p><p>热启动练习包括了五个部分：</p><p>呼吸的练习；</p><p>感受你的心跳；</p><p>回忆你值得感恩的事；</p><p>想一想你值得改善和庆祝的事；</p><p>想一想你的三个目标。</p><p>完整的练习需要15分钟的时间，为了方便你的练习，我在课程的最后准备了完整的练习音频，你可以去试一试。</p><p>我自己每天都做这个练习，可以提醒自己感恩的事、值得分享的事、庆祝的事以及我自己的目标是什么。</p><p>这些都是我们需要的正面的情绪，当正面的情绪被激发出来，就好像是身体做了热身一样，更容易抵抗寒冷。</p><p>你不要小看这一个小小的练习，心理学家其实做了不少的研究，发现我们在情绪上小小的差别，能够给人的认知和判断产生巨大的影响。</p><p>比如美国耶鲁大学的研究者做过一个电梯测试，他们在电梯里随机选择了两组学生，让他们帮自己拿一下咖啡。唯一的差别是一组学生的咖啡是冰的，另一组是热的。</p><p>最后学生们从电梯里出来被要求对同一组陌生人的脸进行好感度评分。结果拿了热咖啡的学生对别人的好感度会更高。这说明，如果自己的身体热起来了，会影响我们对别人的看法。</p><p>热启动练习里面会让我们回忆感恩的时刻，这是一个非常重要的部分。 因为心里的感恩会让我们更容易觉得快乐，会更少觉得抑郁。</p><p>现在你学会了如何激发自己的正面情绪，掌握了情绪的遥控器。接下来，我跟你说一说我们常见的负面情绪。因为只有了解负面情绪，我们才能有意识地去减少它。</p><p>如何缓解焦虑情绪</p><p>对于职场人士来说，焦虑和抑郁是最常见的两种负面情绪。 </p><p>其实我们每个人在人生的不同阶段都经历过焦虑或者抑郁的状态。</p><p>我先来说一说焦虑。 </p><p>焦虑的体验其实就是我们常说的担心或者害怕，是我们对于危险和不确定性的一种正常反应。 </p><p>它的好处是帮助我们对这个世界更加警觉，但一般的焦虑不会影响到我们的生活。</p><p>但是如果焦虑持续地扩散或者出现急性的惊恐发作，以及莫名其妙的那种担心、坐立不安，你都不知道在担心什么。</p><p>有时候还会伴随着植物神经功能的失调，比如说手抖、出汗、尿频、心悸或者运动性的不安。这种情况在医学上可能就是焦虑症，一定要去就医。</p><p>如果你一段时间都处于很焦虑的状态，有一些方法可以缓解。比如说放松呼吸练习，这是冥想里面的一种基本的技巧。</p><p>它主要是让你专注于你的呼吸，把你的注意力锚定在你的呼吸上，通过这个练习可以让你精神更放松，注意力更集中。</p><p>为了方便你的练习，我在课程的最后也做了专门的练习音频，你可以试一试。</p><p>需要注意的是，放松呼吸练习。如果你是第一次做，刚开始的时候可能并不能够专注。但是没有关系，你需要坚持一段时间，慢慢地就会适应。</p><p>一旦你掌握了这个方法，你可以在生活中随时随地地使用，随时用它来调整自己的情绪。</p><p>第二个方法是情绪标签法，英文里叫做mental noting，这个方法可以跟我们之前说的呼吸练习一起做。</p><p>如果你自己觉得非常焦虑，焦虑感在你脑子里挥之不去的时候，你可以试试通过给焦虑打上标签的方法来缓解焦虑。</p><p>怎么做呢？你可以在内心对自己说，这个感觉就是焦虑，我焦虑的时候会觉得心跳加速、手掌出汗。</p><p>如果你能在意识上去认知到焦虑的感觉，那你也就不那么焦虑了。因为你已经从这个感觉里跳出来站在旁边观察它了。</p><p>第三个方法就是把焦虑的事情写下来并且列出相应的对策。</p><p>为什么写下来能够减轻我们的焦虑感呢？因为焦虑的发生常常有两个因素。</p><p>一是过度专注，也就是我们常说的钻牛角尖，这需要我们转移注意力来缓解。</p><p>另一个原因就是我们找不到解决的方法，觉得担心，但是没有答案，导致焦虑泛化。</p><p>所以把问题写下来就能够让注意力转移到纸上，而不是问题上。写出解决问题的方法，就算不完美，也能朝解决问题的方向迈出一小步，焦虑感就会随之减少。</p><p>如何预防抑郁症</p><p>职场上常见的负面情绪除了焦虑，还有抑郁。</p><p>和焦虑不一样，抑郁主要的表现是情绪低落，感觉不到快乐，也没有动力。严重的话可能悲观厌世，甚至产生自杀的想法。</p><p>其实我们大部分人遇到失败或者挫折的时候，都会有过短暂的情绪低落。但一段时间以后，基本上就恢复了。抑郁的状态如果持续超过了两周，在临床上就会被诊断为抑郁症。</p><p>应该怎么预防抑郁症呢？我给你讲两个小技巧：</p><p>第一是感恩的心态；</p><p>第二是运动。</p><p>其实抑郁症一个重要的原因就是感觉不到快乐，而要感觉到快乐最简单的方法就是培养感恩的心态。</p><p>我举一个例子，同样公司发我一万块钱。如果我觉得感恩的话，就会觉得我在公司学了这么多东西，还能挣到钱，真是太好了，太高兴了。</p><p>另外一个人觉得我干了这么多活才给一万块钱，太亏了。同样的待遇，一个人能感觉到很多的快乐，一个人觉得非常悲惨，其实差别就是你有没有感恩的心态。</p><p>另外医学的研究表明，运动对于抑郁症的治疗非常有效。 五公里的跑步对于抑郁症的效果基本上相当于吃一种抗抑郁的药品。</p><p>所以你感觉不开心、不高兴了，那就积极地去运动吧。还记得第二讲里面，我跟你讲的随时运动的小技巧吗？赶紧用起来。</p><p>很多人不太了解焦虑症和抑郁症，觉得非常恐惧，不愿意去看医生。其实这两种疾病都是精神科最常见的。</p><p>全球有将近十分之一的人都在一生中患过这两种疾病，医学上甚至把它们叫做大脑的感冒。</p><p>所以如果你碰到了，或者同事朋友碰到了，一定不要害怕。它们的诊断和治疗都很标准，而且疗效也非常好，一定要去看医生。</p><p>本讲小结</p><p>我讲了情绪对于精力的影响，好比汽车发动机里的火花塞一样，你可以用热身的方法点燃自己。</p><p>同样当你遇到了负面的情绪，尤其是焦虑、抑郁的时候，你要记得人的脑子就像一台电视机，你有遥控器，你可以主动地换频道，你可以用呼吸练习、情绪标签、运动、感恩的方法来对抗负面的情绪。</p><p>最后，我还想送给你一句话，爱默生曾经说过， “一个人对这个世界最大的贡献就是让自己幸福起来。” 掌握了情绪管理的能力就是让自己幸福的秘密。</p><p>你有哪些应对负面情绪的好方法？欢迎你在留言区跟大家分享，让我们一起有一个好心情。</p><p>接下来我会跟你说一说，怎么样训练我们的注意力和意义感，让我们能够高效地使用精力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文章摘自：得到APP 张遇升《怎样成为精力管理的高手》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于情绪的三条定律&lt;/p&gt;
&lt;p&gt;关于情绪有三条重要的定律，这可不是我忽悠你，这是很多心理学家研究的发现。哪三条呢？&lt;/p&gt;
&lt;p&gt;第一条，人的脑子在</summary>
      
    
    
    
    <category term="好文分享" scheme="http://yoursite.com/categories/%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="管理情绪" scheme="http://yoursite.com/tags/%E7%AE%A1%E7%90%86%E6%83%85%E7%BB%AA/"/>
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="http://yoursite.com/2020/05/16/vue%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/05/16/vue%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-15T18:59:34.000Z</published>
    <updated>2020-06-28T01:10:18.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述和脚手架"><a href="#概述和脚手架" class="headerlink" title="概述和脚手架"></a>概述和脚手架</h2><blockquote><p>前言：首先确保自己的开发环境，这里不再赘述。</p></blockquote><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><ul><li>Vue.js 是目前最火的一个前端<strong>框架</strong>，React是最流行的一个前端框架。</li><li>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</li><li>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。</li><li>Vue 核心的概念，就是让用户不再操作DOM元素，提高渲染效率，前端程序员只需要关心数据的业务逻辑，不再关系 DOM 是如何渲染的。</li></ul><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>打开我们的终端工具，全局安装脚手架 ，以及创建第一个vue的项目</p><ol><li><p>@vue/cli全局安装   也可以限制版本号；  vue/cli@3</p><p>安装： npm install -g @vue/cli  也可以使用自己的安装方式 ：yarn…</p></li><li><p>使用 vue create  “项目名称”  第一次我们可以选择默认的配置进行创建</p></li><li><p>创建完成后会出现一个文件夹  按照终端的提示进入创建的目录  在执行  npm  run  serve出现以下提示</p></li></ol><p>   <img src="/images/vueimg/1.jpg" alt="1"></p><ol start="4"><li>我们在自己的浏览器中输入以上的地址就可以看到我们默认创建的第一个vue项目了<img src="/images/vueimg/vue2.png" alt=""></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述和脚手架&quot;&gt;&lt;a href=&quot;#概述和脚手架&quot; class=&quot;headerlink&quot; title=&quot;概述和脚手架&quot;&gt;&lt;/a&gt;概述和脚手架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前言：首先确保自己的开发环境，这里不再赘述。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>生而不凡读书笔记</title>
    <link href="http://yoursite.com/2020/05/16/%E7%94%9F%E8%80%8C%E4%B8%8D%E5%87%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/05/16/%E7%94%9F%E8%80%8C%E4%B8%8D%E5%87%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-15T18:00:06.000Z</published>
    <updated>2020-05-17T16:42:35.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、跳出普世规则"><a href="#1、跳出普世规则" class="headerlink" title="1、跳出普世规则"></a>1、跳出普世规则</h2><p><strong>学会质疑我们所处世界的种种规则</strong></p><p>从小到大，总有人和你说，世界就是这副模样，你便要在这样的世界里过活；不要碰壁太多次；要去拥有一个不错的家庭生活，找点乐子，存点钱。那是一种非常局限的生活。一旦你发觉一个简单的事实，生活会无比宽广。那就是围绕着你的叫作生活的一切，是由并不比你更聪明的人所创造的。而且，你能影响和改变这一切……一旦你明白了这点，你将不再是原来的自己。</p><p>——史蒂夫·乔布斯</p><h2 id="2、放下胡扯规则"><a href="#2、放下胡扯规则" class="headerlink" title="2、放下胡扯规则"></a>2、放下胡扯规则</h2><p>怎么放下胡扯规则？</p><p>如果违背了已所不欲勿施于人，有些可能也是胡扯规则，</p><p>是否符合自己的福祉，不要被教条所困。</p><h2 id="3、带上意识工程的工具箱"><a href="#3、带上意识工程的工具箱" class="headerlink" title="3、带上意识工程的工具箱"></a>3、带上意识工程的工具箱</h2><h2 id="4、选择能赋予你能量的现实认知"><a href="#4、选择能赋予你能量的现实认知" class="headerlink" title="4、选择能赋予你能量的现实认知"></a>4、选择能赋予你能量的现实认知</h2><h2 id="5、别忘记将你的行为方式放进行囊"><a href="#5、别忘记将你的行为方式放进行囊" class="headerlink" title="5、别忘记将你的行为方式放进行囊"></a>5、别忘记将你的行为方式放进行囊</h2><h2 id="6、意志坚定地改造现实世界"><a href="#6、意志坚定地改造现实世界" class="headerlink" title="6、意志坚定地改造现实世界"></a>6、意志坚定地改造现实世界</h2><h2 id="7、以快乐自律"><a href="#7、以快乐自律" class="headerlink" title="7、以快乐自律"></a>7、以快乐自律</h2><h2 id="8、把你的目标紧紧地握在手中"><a href="#8、把你的目标紧紧地握在手中" class="headerlink" title="8、把你的目标紧紧地握在手中"></a>8、把你的目标紧紧地握在手中</h2><h2 id="9、修炼强大内心，变得无懈可击"><a href="#9、修炼强大内心，变得无懈可击" class="headerlink" title="9、修炼强大内心，变得无懈可击"></a>9、修炼强大内心，变得无懈可击</h2><h2 id="10、打开那扇门，步伐坚定地踏上属于你的未来征途。"><a href="#10、打开那扇门，步伐坚定地踏上属于你的未来征途。" class="headerlink" title="10、打开那扇门，步伐坚定地踏上属于你的未来征途。"></a>10、打开那扇门，步伐坚定地踏上属于你的未来征途。</h2><p>世界正迫不及待地想要看你接下来会做什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、跳出普世规则&quot;&gt;&lt;a href=&quot;#1、跳出普世规则&quot; class=&quot;headerlink&quot; title=&quot;1、跳出普世规则&quot;&gt;&lt;/a&gt;1、跳出普世规则&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学会质疑我们所处世界的种种规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从小到大，总</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课外阅读" scheme="http://yoursite.com/tags/%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>亲密关系读书笔记</title>
    <link href="http://yoursite.com/2020/04/11/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/11/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-11T05:02:30.000Z</published>
    <updated>2020-04-26T10:51:17.906Z</updated>
    
    <content type="html"><![CDATA[<p><strong>寻找真挚永恒的亲密关系,其实就是寻找自我;</strong>  —克里斯多福 . 孟</p><p>在经历了很长一段时间之后我们的关系就会趋于平淡，但是这种平淡都会使得我们有一种错觉，容易让我们陷入胡思乱想当中。这也就是我们到后面就只知道我们彼此的缺点了，忘记了我们当初吸引我们的优点。</p><p><strong>闪闪发光物，并非尽黄金。 —格言</strong></p><p>我们心甘情愿为爱盲目，被爱吞噬，从童稚的少年到迟暮的老年，每个人都向往在遇到一生真爱时的那种心动感觉。我们是如此深信爱情的力量，以至于两个“找到彼此”的人的邂逅，成了无数著作与电影的灵感。在小说主角之外的真实人生中，有些人确实能找到真命天子，且努力维持住初识时的热情之火。</p><p>我相信恐惧与无知是造成所谓的“亲密关系失败”的两大原因。</p><p>只要明白了情感的倾向，亲密关系就可能有结果，而让我们有一窥真爱的机会。</p><p>我们都会希望找到一个为了我们可以抛弃全世界，而且永远把我们放在第一位的理想爱人。</p><p>一个人满怀热情，排除万难，只为了和另一个人心灵相系，是多么美好的事！但是这个路上都会有很多的插曲，我们唯一做的就是要有自信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;寻找真挚永恒的亲密关系,其实就是寻找自我;&lt;/strong&gt;  —克里斯多福 . 孟&lt;/p&gt;
&lt;p&gt;在经历了很长一段时间之后我们的关系就会趋于平淡，但是这种平淡都会使得我们有一种错觉，容易让我们陷入胡思乱想当中。这也就是我们到后面就只知道我们彼此的缺点了，忘</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课外阅读" scheme="http://yoursite.com/tags/%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="http://yoursite.com/2020/04/11/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/11/git%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-11T04:46:48.000Z</published>
    <updated>2020-04-28T11:51:52.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h2><h3 id="本地代码创建基本结构推送到远程仓库"><a href="#本地代码创建基本结构推送到远程仓库" class="headerlink" title="本地代码创建基本结构推送到远程仓库;"></a>本地代码创建基本结构推送到远程仓库;</h3><ul><li>1 . 配置全局环境 : 仅需配置一次就可以了;</li></ul><p>配置指令 :<br><code>git config --global user.name &quot;你自己的用户名&quot;</code><br><code>git config --global user.email &quot;你自己的qq邮箱&quot;</code></p><p>如何查看配置是否成功 : C:/user/用户名/.gitconfig 配置文件，永久存在于你的电脑上;</p><ul><li><ol start="2"><li><p>建立本地仓库 : </p><p>代码存在计算机的某个位置<br>git仓库文件夹叫做 .git 隐藏文件夹  </p><p>指令 : <code>git init</code>;</p><p>提示 : Initialized empty Git repository in 路径  初始化了一个空的仓库在对应的路径上;</p></li></ol></li><li><ol start="3"><li><p>git指令 : </p><ol start="4"><li><code>git add -A</code>  把你的代码放到缓存区之中;<br>-A : 所有文件;</li><li><code>git commit -m</code>  把你的代码放到<strong>本地</strong>仓库之中。<br>-m : 标明每次提交都要有注释。  注释里一定说明白你改了哪些东西; </li><li><code>git remote add origin https://gitee.com/NZG201/G201-git.git</code> 给当前的源(网上的仓库路径取个别名，叫做 origin , 以后使用的时候 origin 就等于 <a href="https://gitee.com/NZG201/G201-git.git" target="_blank" rel="noopener">https://gitee.com/NZG201/G201-git.git</a> ) 一个仓库只需要配置一次;</li><li><code>git push -u origin master</code> </li></ol><p>git push : 表示把本地仓库的内容推送到线上仓库。<br>-u       : 表示所有的更新;<br>origin   : 之前设置的原路径变量;<br>master   : 分支;</p></li></ol></li></ul><p>正确顺序是 : 1. 配置用户名邮箱 2. 创建初始化仓库(一个项目初始化一个仓库即可); 3. git提交指令;</p><h3 id="远程仓库代码下载到本地并进行更改"><a href="#远程仓库代码下载到本地并进行更改" class="headerlink" title="远程仓库代码下载到本地并进行更改"></a>远程仓库代码下载到本地并进行更改</h3><ol><li><code>git clone 仓库路径</code>  : 适用场景，没有仓库别人已经写了一部分代码了;</li><li><code>git pull  同步仓库</code>  : 你的本地存在部分仓库之中的代码，想要继续去进行更新;</li><li><code>git fetch 拉取仓库</code>  : 本地仓库 .git 同步线上的仓库;</li></ol><h3 id="远程端的代码发生改变了，和我本地的代码不一致，我应该怎么办呐"><a href="#远程端的代码发生改变了，和我本地的代码不一致，我应该怎么办呐" class="headerlink" title="远程端的代码发生改变了，和我本地的代码不一致，我应该怎么办呐?"></a>远程端的代码发生改变了，和我本地的代码不一致，我应该怎么办呐?</h3><ol><li>提交代码到本地仓库;       git add , git commit </li><li>线上代码同步到本地仓库;   git pull<br>合并代码 : vscode 工具; 肉眼进行合并;</li><li>重新修改之后进行提交。    git add , git commit , git push …</li></ol><h2 id="作为仓库的拉取者-你的操作会对仓库有怎样的影响那"><a href="#作为仓库的拉取者-你的操作会对仓库有怎样的影响那" class="headerlink" title="作为仓库的拉取者 你的操作会对仓库有怎样的影响那?"></a>作为仓库的拉取者 你的操作会对仓库有怎样的影响那?</h2><blockquote><p>作为克隆仓库的开发人员,我用clone创建了仓库。<br>我在仓库里面的代码进行了部分的更新。<br>我又把代码提交到远程仓库。</p></blockquote><p>clone的仓库有哪些东西 : </p><pre><code>1. 仓库里面所有的代码。2. 仓库里面所有的版本。3. 仓库里面的源 ;</code></pre><h3 id="务必记住clone之后，一定要进入到克隆的文件夹里面去操作项目，别在外面操作"><a href="#务必记住clone之后，一定要进入到克隆的文件夹里面去操作项目，别在外面操作" class="headerlink" title="务必记住clone之后，一定要进入到克隆的文件夹里面去操作项目，别在外面操作;"></a>务必记住clone之后，一定要进入到克隆的文件夹里面去操作项目，别在外面操作;</h3><p>你好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h1&gt;&lt;h2 id=&quot;代码托管&quot;&gt;&lt;a href=&quot;#代码托管&quot; class=&quot;headerlink&quot; title=&quot;代码托管&quot;&gt;&lt;/a&gt;代码托</summary>
      
    
    
    
    <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://yoursite.com/2020/04/10/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/10/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2020-04-09T19:20:05.000Z</published>
    <updated>2020-04-10T09:01:52.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h2 id="为啥需要工程化"><a href="#为啥需要工程化" class="headerlink" title="为啥需要工程化"></a>为啥需要工程化</h2><pre><code>- 就是因为程序员比较懒。- 使用工具替我们完成某些工作。</code></pre><h2 id="代码的优化，-工程的优化"><a href="#代码的优化，-工程的优化" class="headerlink" title="代码的优化， 工程的优化"></a>代码的优化， 工程的优化</h2><pre><code>- 为了确保项目的可扩展性，健壮性，我们需要有工程化的思想构建我们的项目;- 1. 开发环境 : 主要以演示为主， 代码编程过程之中随时可以查看。             :  服务器代理功能- 2. 生产环境 : 主要以产出代码为主，我们要产出压缩好的，兼容性良好的代码。总结 : 其实工程化就是让我们在开发程序的时候可以有更明确的功能分类，通过工程化工具去构建，去完善，最终变成我们的优秀的产出物。</code></pre><h2 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a>工程化工具</h2><pre><code>gulp    小众类别-简单webpack 目前主流基于webpack的工程化构建 ...</code></pre><h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><pre><code>基于工作流的工程化构建工具。</code></pre><h2 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h2><ol><li><p>基本环境安装 : gulp </p><p>全局gulp : 可以在cmd命令行之中使用gulp指令; (一台电脑安装一次即可)</p><p>安装指令 : <code>npm install gulp-cli -g</code></p><p>局部gulp : 给gulp提供核心功能的支持; (每个项目都需要重新安装)</p><p>安装指令 : <code>npm install gulp --save-dev</code></p></li><li><p>基本环境测试 : </p><p>测试 : <code>gulp -v</code></p></li></ol><blockquote><p>CLI version: 2.2.0<br>Local version: 4.0.2</p></blockquote><h2 id="配置VSCode命令行"><a href="#配置VSCode命令行" class="headerlink" title="配置VSCode命令行"></a>配置VSCode命令行</h2><ol><li><p>呼出 : <code>ctrl + ~</code></p></li><li><p>统一命令行的指令工具 : <code>CMD</code></p><ol><li>找到cmd的根目录 <code>C:\WINDOWS\system32\cmd.exe</code></li><li>在设置之中找到终端 填写路径;</li></ol></li></ol><h2 id="工程化目录结构"><a href="#工程化目录结构" class="headerlink" title="工程化目录结构"></a>工程化目录结构</h2><ul><li>src : 存放我们开发之中的代码;</li></ul><ol><li>构建项目说明书 ; <code>npm init -y</code></li></ol><p>如果下载失败 :<br>    1. 换个热点重新下载;<br>    2. 执行指令 <code>npm cache clear --force</code> , 重复1;<br>    3. 如果2不生效 , 找到npm的缓存文件删除掉;<br>    在路径 <code>C:\Users\Administrator</code> 下面找到npmrc | nrmrc 直接删除 , 再从1 开始重新尝试;<br>    4. 如果2，3都不生效 , 找到npm全局环境安装目录， 删除掉所有的内容 。 那个装不上，就删除哪个就可以了。<br>    5. 2,3,4 都不生效 需要重新执行4 ，卸载nodejs =&gt; 重启 =&gt; 安装nodejs =&gt; 重启 =&gt; 重新安装<br>    6. 1~5 都不好用, 检查源是否存在，是否被防火墙阻拦。<br>    7. 检查其他模块是否可以下载<br>    8. 实在不行重装个系统吧.</p><h2 id="gulp基本指令"><a href="#gulp基本指令" class="headerlink" title="gulp基本指令"></a>gulp基本指令</h2><ul><li><ol><li><p>把src之中 ， html 文件夹之下的index.html 转存到 dist文件夹下 </p><p><code>gulp.task(&quot;指令名称&quot; , 指令回调函数)</code><br><code>gulp.src([数组之中写入文件路径])</code><br><code>.pipe(操作工具)</code><br><code>gulp.dest(转存路径)</code><br><code>gulp.watch(监听路径,指令指令)</code><br><code>series([&quot;指令1&quot;,&quot;指令2&quot;])</code>    上一个指令执行完，才会执行下一个指令;<br><code>parallel([&quot;指令1&quot;,&quot;指令2&quot;])</code>  多个指令同时执行</p></li></ol></li></ul><h2 id="使用第三方gulp插件"><a href="#使用第三方gulp插件" class="headerlink" title="使用第三方gulp插件"></a>使用第三方gulp插件</h2><ul><li><p>gulp-connect </p><ol><li>安装 : <code>npm install --save-dev gulp-connect</code></li><li>在 gulpfile.js 之中引入插件;</li><li>插件的使用配置，有些插件的语法是gulp3语法，会和现在gulp4语法存在冲突，所以我们需要根据实际情况进行一定的更新;</li></ol></li><li><p>目标 : 让nodejs服务器可以进行接口代理。</p></li><li><p>http-proxy-middleware</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">middleware : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 返回值必须是数组;</span></span><br><span class="line">    <span class="comment">// 默认访问的路径 : http://localhost/pxx</span></span><br><span class="line">    <span class="comment">// 被处理之后的路径 : 代理路径/pxx;</span></span><br><span class="line">    <span class="comment">// 重写路径 : /pxx =&gt; ""; 代理路径</span></span><br><span class="line">    <span class="keyword">return</span> [ </span><br><span class="line">        proxy( <span class="string">"/pxx"</span> ,  &#123;</span><br><span class="line">            target : <span class="string">"https://apiv2.pinduoduo.com/api/gindex/subject/limited/goods"</span>,</span><br><span class="line">            changeOrigin : <span class="literal">true</span>,</span><br><span class="line">            pathRewrite : &#123;</span><br><span class="line">                  <span class="string">"/pxx"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        proxy(<span class="string">"/dt"</span>, &#123;</span><br><span class="line">            target :<span class="string">" https://www.duitang.com/napi/blog/list/by_filter_id/"</span>,</span><br><span class="line">            changeOrigin : <span class="literal">true</span>,</span><br><span class="line">            pathRewrite : &#123;</span><br><span class="line">                <span class="string">"/dt"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分环境"><a href="#拆分环境" class="headerlink" title="拆分环境"></a>拆分环境</h2><ol><li>开发环境 : 需要立即看到代码效果;</li><li>生产环境 : 要最优质的代码; 代码压缩，混淆，缓存处理……..</li></ol><ul><li><p>实际操作 </p><ul><li><ol><li><p>拆分两个gulp配置文件 : gulpfile.dev.js  gulpfile.build.js</p><ul><li>gulpfile.dev.js   =&gt; 开发环境 : 配置了服务器，配置了代理，配置转存….</li><li>gulpfile.build.js =&gt; 生产环境 : 代码压缩，代码转义…..</li></ul></li></ol></li><li><ol start="2"><li><p>区分用户输入的指令，决定加载哪一个配置文件;</p><p><code>process.argv</code> 通过这个属性进行获取;</p></li></ol></li></ul></li></ul><h2 id="gulp-dev"><a href="#gulp-dev" class="headerlink" title="gulp dev"></a>gulp dev</h2><pre><code>1. 让我们根据 process.argv 判定应该加载哪一个配置文件;2. gulp的指令执行;</code></pre><h2 id="gulp-build"><a href="#gulp-build" class="headerlink" title="gulp build"></a>gulp build</h2><pre><code>1. js 代码的转义 ES6 =&gt; ES5  2. js , css , html , 代码压缩 3. 给 js , css 添加版本后缀, 使用缓存的同时可以识别新的版本;4. 图片优化</code></pre><ul><li>插件构成 : <ul><li>gulp-babel  安装参照npmjs.org</li><li>gulp-uglify 代码压缩; </li></ul></li></ul><p>无论任何时候，你修改的代码只有src里面的代码，不会修改dist里面的代码，dist里面的代码都是工程化生成的;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端工程化&quot;&gt;&lt;a href=&quot;#前端工程化&quot; class=&quot;headerlink&quot; title=&quot;前端工程化&quot;&gt;&lt;/a&gt;前端工程化&lt;/h2&gt;&lt;h2 id=&quot;为啥需要工程化&quot;&gt;&lt;a href=&quot;#为啥需要工程化&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
